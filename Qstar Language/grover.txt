|| grover || (int N, circ oracle)
pre {some pre expression} , {yet another expression}
	circ qr, aux ->
		if len(qr) == 0 {
			assert { |qr> = |qr'> }
			return
		}
		else {
            init(qr,aux)
            assert{assert after initialization}
            for i in range(sqrt(N/2)) {
                invariant{inv1}
                grover_iter(qr,aux,oracle)
                assert {formula}
            }
        }
pos {some pos expression}

| grover_iter | (qreg qr, qreg aux, circ oracle)
pre {some-expression}
	circ qr ->
		if len(qr) == 0 {
			assert { |qr> = |qr'> }
			return
		}
		else {
            oracle(qr,aux)
            diffusor(qr)
            assert{formula}
        }
pos {some expression}

| init | (qreg qr, qreg aux)
pre {some-expression}
    circ qr, aux ->
        for q in qr[:-1] {
            invariant {inv1}
            H(q)
            assert { |qr> = ps_had |qr'> (len(qr')-1)}
        }
        X(aux)
        assert {exp}
        H(aux)
        assert {exp}
pos {some expression}

# can be passed as a parameter in main function
| oracle | (qreg qr)
pre {some-expression}
    circ qr -> # DEFINE P /\ (neg Q \/ R)
pos {some expression}


| diffusor | (qreg qr, qreg aux)
pre {some-expression}
    circ qr, aux ->
        for q in qr {
            invariant {inv1}
            H(q)
            assert { |qr> = ps_had |qr'> (len(qr')-1)}
        }
        for q in qr {
            invariant {inv1}
            X(q)
            assert { |qr> = ps_xgate |qr'> (len(qr')-1)}
        }
        H(qr[-1])
        assert { |qr> = ps_had |qr'> (len(qr')-1)}
        with control qr[:-1] (X(qr[-1]))
        assert { |qr> = ps_xgate |qr'> (len(qr')-1)}
        H(qr[-1])
        assert { |qr> = ps_had |qr'> (len(qr')-1)}
        for q in qr {
            invariant {inv1}
            X(q)
            assert { |qr> = ps_xgate |qr'> (len(qr')-1)}
        }
        for q in qr {
            invariant {inv1}
            H(q)
            assert { |qr> = ps_had |qr'> (len(qr')-1)}
        }
pos {some expression}