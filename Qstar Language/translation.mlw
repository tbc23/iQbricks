module Program

use export binary.Bit_vector
use wired_circuits.Circuit_c
use export p_int.Int_comp
use ref.Ref
use qbricks.Circuit_macros
use int.Int
use wired_circuits.Qbricks_prim
use qbricks.Circuit_semantics
use exponentiation.Int_Exponentiation
use unit_circle.Angle

let diffusor (qr aux n: int): circuit
requires{0<n}
requires{qr+aux=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
let circ_aux = ref (m_skip n) in
for i=0 to (qr-1) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place_hadamard i n);
done;
c0 := !c0 -- !circ_aux;
let circ_aux = ref (m_skip n) in
for i=0 to (qr-1) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place xx i n);
done;
c0 := !c0 -- !circ_aux;
c0 := !c0 -- (cont (( zz (qr-1 - 1) n) (0) (qr-1 - 1)));
assert{true};
let circ_aux = ref (m_skip n) in
for i=0 to (qr-1) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place xx i n);
done;
c0 := !c0 -- !circ_aux;
assert{true};
let circ_aux = ref (m_skip n) in
for i=0 to (qr-1) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place_hadamard i n);
done;
c0 := !c0 -- !circ_aux;
return (!c0);
ensures{true}
end

let oracle (qr n: int): circuit
requires{0<n}
requires{qr=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
return (!c0);
ensures{true}
end

let grover_iter (qr n: int): circuit
requires{0<n}
requires{qr=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
c0 := !c0 -- (diffusor (qr aux n));
c0 := !c0 -- (oracle (qr aux n));
return (!c0);
ensures{true}
end

let init (qr aux n: int): circuit
requires{0<n}
requires{qr+aux=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
let circ_aux = ref (m_skip n) in
for i=0 to (aux-1) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place_hadamard i n);
done;
c0 := !c0 -- !circ_aux;
assert{true};
let circ_aux = ref (m_skip n) in
for i=0 to (aux-1) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place xx i n);
done;
c0 := !c0 -- !circ_aux;
assert{true};
let circ_aux = ref (m_skip n) in
for i=0 to (qr-1 - 1) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place_hadamard i n);
done;
c0 := !c0 -- !circ_aux;
return (!c0);
ensures{true}
end

let grover (qr aux n: int): circuit
requires{0<n}
requires{qr+aux=n}
requires{qr = 4}
requires{aux = 1}
requires{true}
=
begin
let c0 = ref (m_skip n) in
c0 := !c0 -- (init (qr aux n));
let c1 = ref (m_skip n) in
for i = 0 to (iters) do
invariant{width !c1=n}
invariant{true}
c1 := !c1 -- (grover_iter (qr aux n));

done;
c0 := !c0 -- !c1;
return (!c0);
ensures{true}
end

end
