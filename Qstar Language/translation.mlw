module Program

use export binary.Bit_vector
use wired_circuits.Circuit_c
use export p_int.Int_comp
use ref.Ref
use qbricks.Circuit_macros
use int.Int
use reversion.Circuit_reverse
use wired_circuits.Qbricks_prim
use qbricks.Circuit_semantics
use int_expo.Int_Exponentiation
use unit_circle.Angle

let diffusor (qr aux n: int): circuit
requires{0<n}
requires{qr+aux=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
let c1 = ref (m_skip n) in
let c2 = ref (m_skip n) in
c2 := !c2 -- cont  zz (0) (qr - 1) n;
assert{true};
let circ_aux = ref (m_skip n) in
for i=0 to (qr) do
invariant{width !c1=n}
circ_aux := !circ_aux -- (place xx i n);
done;
c1 := !c1 -- !circ_aux -- !c2 -- reverse (!circ_aux);
let circ_aux = ref (m_skip n) in
for i=0 to (qr) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place_hadamard i n);
done;
c0 := !c0 -- !circ_aux -- !c1 -- reverse (!circ_aux);
return !c0;
ensures{true}
end

let oracle (qr n: int): circuit
requires{0<n}
requires{qr=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
return !c0;
ensures{true}
end

let grover_iter (qr aux n: int): circuit
requires{0<n}
requires{qr+aux=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
c0 := !c0 -- (oracle qr n);
c0 := !c0 -- (diffusor qr aux n);
return !c0;
ensures{true}
end

let init (qr aux n: int): circuit
requires{0<n}
requires{qr+aux=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
let circ_aux = ref (m_skip n) in
for i=0 to (qr - 2) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place_hadamard i n);
done;
c0 := !c0 -- !circ_aux;
let circ_aux = ref (m_skip n) in
for i=0 to (aux) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place xx i n);
done;
c0 := !c0 -- !circ_aux;
assert{true};
let circ_aux = ref (m_skip n) in
for i=0 to (aux) do
invariant{width !c0=n}
circ_aux := !circ_aux -- (place_hadamard i n);
done;
c0 := !c0 -- !circ_aux;
assert{true};
return !c0;
ensures{true}
end

let grover (qr aux n: int): circuit
requires{0<n}
requires{qr+aux=n}
requires{qr = 4}
requires{aux = 1}
requires{iters=2}
=
begin
let c0 = ref (m_skip n) in
let c1 = ref (m_skip n) in
for i = 0 to (iters) do
invariant{width !c0=n}
invariant{width !c1=n}
invariant{true}
c1 := !c1 -- (grover_iter qr aux n);
c0 := !c0 -- !c1;

done;
c0 :=(init qr aux n) -- !c0;
return !c0;
ensures{true}
end

end
