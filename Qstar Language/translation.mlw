module Program

use export binary.Bit_vector
use wired_circuits.Circuit_c
use export p_int.Int_comp
use ref.Ref

let qft (qr n: int): circuit
requires{0>n}
requires{qr=n}
requires{true}
=
begin
let c0 = ref (m_skip n) in
let c1 = ref (m_skip n) in
for q = 0 to (qr) do
invariant{width !c1=n}
invariant{0<=q<=qr}
variant{qr-q}
invariant{range !c1 = !q}
invariant{forall x y i. 0<= i < n -> basis_ket !c1 x y i = if 0<= i < !q then y i else x i}
invariant{forall x y. ang_ind !c1 x y = (ind_isum(fun k -> (ind_isum (fun l -> x l * y k * power 2 (n-l - 1+k)) k n))0 !q) /./ n}
let c2 = ref (m_skip n) in
for i = q to (qr - 1) do
invariant{width !c2=n}
invariant{q<=i<=qr - 1}
variant{qr - 1-i}
invariant{range !c2 = 0}
invariant{forall x y i. 0<= i < n -> basis_ket !c2 x y i = x i}
invariant{forall x y. ang_ind !c2 x y = (ind_isum (fun l -> x l * x !q * power 2 (n- l -1+ !q)) (!q+1) !i) /./n}
c2 := !c2 -- (cont (( (rz (n - i - 1)) (q) n) (i + 1) (q)));

done;
c1 := !c1 -- !c2;
c1 := !c1 -- (place_hadamard (q) n);
assert{forall x y i. 0<= i < n -> basis_ket !cl x y i = if i = !q then y 0 else x i}
assert{forall x y. ang_ind !cl x y = (ind_isum (fun l -> x l * y 0 * power 2 (n-l - 1+ !q)) !q n) /./ n}

done;
c0 := !c0 -- !c1;
return (!c0)
assert{true};
ensures{width result = n}
ensures{range result = n}
ensures{forall x y i. 0<= i < n -> basis_ket result x y i = y i}
ensures{forall x y. ang_ind result x y  = (ind_isum(fun k -> (ind_isum (fun l -> x l * y k * power 2 (n-l - 1+k)) k n))0 n) /./ n}

end
end
